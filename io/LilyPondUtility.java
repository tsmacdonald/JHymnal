/**
 * LilyPondUtility.java
 * 
 * Class to hold methods and
 * values which need to be available
 * to both parsers and writers of
 * LilyPond files.
 * 
 * @author Jason Petersen
 */

package io;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.StringTokenizer;

import model.*;

/* See last example on this page for formatting: 
   http://lilypond.org/doc/v2.14/Documentation/learning/voices-and-vocals */

final class LilyPondUtility extends Utility {
	
	/** Singleton */
	private static LilyPondUtility instance = new LilyPondUtility();
	
	/** The LilyPond version, required for backwards compatibility */
	private final String versionNumber = "2.14.2";
	
	/** LilyPond notation for flat accidental */
	private final String flat = "es";
	
	/** LilyPond notation for sharp accidental */
	private final String sharp = "is";
	
	/** This block is used to force LilyPond to create a single page from the given file */
	private static final String paperBlock;
	
	/** This block is used to set the spacing and indentation for the file */
	private static final String layoutBlock;
	
	/* See this page for information about centering: 
	   http://lilypond.org/doc/v2.12/input/lsr/lilypond-snippets/Vocal-music#Vertically-centered-common-lyrics */
	/** This variable is used to center the lyrics vertically for refrains */
	private static final String dropLyrics;
	
	/** This variable is used to stop centering lyrics vertically after refrains */
	private static final String raiseLyrics;
	
	/** Variable indicating two bars, one extra thick for the end of the hymn */
	private static final String endBar;
	
	/** Variable indicating two normally formatted bars */
	private static final String verseBar;
	
	static {
		paperBlock = 	"\\paper {\n" +
							"\tprint-page-number = ##f\n" +
						"}\n";
		layoutBlock = 	"\\layout {\n" + 
							"\tindent = #0\n" +
						"}\n";
		dropLyrics = 	"dropLyrics = {\n" +
							"\t\\override LyricText #'extra-offset = #'(0 . -5)\n" +
							"\t\\override LyricHyphen #'extra-offset = #'(0 . -5)\n" +
							"\t\\override LyricExtender #'extra-offset = #'(0 . -5)\n" +
						"}\n";
		raiseLyrics = 	"raiseLyrics = {\n" +
							"\t\\revert LyricText #'extra-offset\n" +
							"\t\\revert LyricHyphen #'extra-offset\n" +
							"\t\\revert LyricExtender #'extra-offset\n" +
						"}\n";
		endBar =		"endBar = { \\bar \"|.\" }\n";
		verseBar =		"verseBar = { \\bar \"||\" }\n";
	}
	
	/* LilyPond does not allow integers in variable names, ergo we need this mapping */
	/** Array of Strings used to map integers to their String names, e.g. 1 is "One" */
	private static final String[] numberStrings = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine" };
	
	/** Tagline at the end of the page generated by LilyPond */
	private static final String tagline = "Wheaton College Spring 2012";
	
	/** Names of the verse variables created. This is added to in createVerses */
	private static ArrayList<String> verseVariables = new ArrayList<String>();
	
	/** 
	 * Constructor for Singleton.
	 * @author Jason Petersen 
	 */
	private LilyPondUtility() { }
	
	/**
	 * Accessor method for the singleton of LilyPondUtility
	 * @return The singleton of LilyPondUtility
	 * @author Jason Petersen
	 */
	static LilyPondUtility getInstance() {
		return instance;
	}
	
	/* ---------- Methods for String creation ---------- */
	
	/**
	 * Transform a Hymn into a LilyPond-formatted String which
	 * can be used in LilyPond or to create a LilyPond file.
	 * @param hymn The Hymn for which to make the LilyPond-formatted String.
	 * @return The Hymn as a LilyPond-formatted String.
	 * @author Jason Petersen
	 */
	String createString(Hymn hymn) {
		if(hymn == null) return "";
		
		verseVariables.clear();
		Tune tune = hymn.getTune();
		
		// Add version number
		String asString = "\\version \"" + versionNumber + "\"\n\n";
		
		// Add properties for image generation
		asString += paperBlock + "\n";
		asString += layoutBlock + "\n";

		// Add lyric vertical modifiers
		asString += dropLyrics + "\n";
		asString += raiseLyrics + "\n";
		
		// Add variables for bars at end of hymn
		asString += verseBar;
		asString += endBar + "\n";
		
		// Add variable keyTime which sets the key, time and starting beat
		asString += createKeyTime(tune) + "\n";

		asString += createAlleluiaLyrics(tune) + "\n"; // Add alleluias
		if(hymn.displayChorus()) asString += createChorus(tune) + "\n"; // Add chorus if it's to be displayed
		
		asString += createVoices(tune) + "\n";	// Add voices
		asString += createVerses(hymn) + "\n";	// Add verses
		
		asString += createHeader(hymn) + "\n"; // Add the header
		asString += createScore(true, hymn.displayChorus()); // Create the score
		
		return asString;
	}
	
	/**
	 * Transform a Tune into a LilyPond-formatted String which
	 * can be used in LilyPond or to create a LilyPond file.
	 * @param tune The Tune for which to make the LilyPond-formatted String.
	 * @return The Tune as a LilyPond-formatted String.
	 * @author Jason Petersen
	 */
	String createString(Tune tune) {
		if(tune == null) return "";
		
		// Add version number
		String asString = "\\version \"" + versionNumber + "\"\n\n";
		
		// Add properties for image generation
		asString += paperBlock + "\n";
		asString += layoutBlock + "\n";

		// Add lyric vertical modifiers
		asString += dropLyrics + "\n";
		asString += raiseLyrics + "\n";
		
		// Add variables for bars at end of hymn
		asString += verseBar;
		asString += endBar + "\n";
		
		// Add variable keyTime which sets the key, time and starting beat
		asString += createKeyTime(tune) + "\n";
		
		asString += createAlleluiaLyrics(tune) + "\n"; // Add alleluias
		if(tune.hasChorus()) asString += createChorus(tune) + "\n"; // Add chorus if it's to be displayed
		
		// Add the voices
		asString += createVoices(tune) + "\n";
		
		asString += createHeader(tune) + "\n"; // Add the header
		asString += createScore(true, tune.hasChorus()); // Create the score
		
		return asString;
	}
	
	/**
	 * Transform a Tune into a LilyPond-formatted String which
	 * can be used in LilyPond or to create a LilyPond file.
	 * @param tune The Tune for which to make the LilyPond-formatted String.
	 * @return The Tune as a LilyPond-formatted String.
	 * @author Jason Petersen
	 */
	String createString(Text text) {
		if(text == null) return "";
		verseVariables.clear();
		
		// Add version number
		String asString = "\\version \"" + versionNumber + "\"\n\n";
		
		// Add properties for image generation
		asString += paperBlock + "\n";
		asString += layoutBlock + "\n";

		// Add lyric vertical modifiers
		asString += dropLyrics + "\n";
		asString += raiseLyrics + "\n";
		
		// Add variables for bars at end of hymn
		asString += endBar + "\n";
		
		// Add the voices
		asString += createVerses(text) + "\n";
		
		asString += createHeader(text) + "\n"; // Add the header
		asString += createScoreForText(); // Create the score
		
		return asString;
	}
	
	/* ---------- Helper functions to create the LilyPond variables ---------- */
	
	/**
	 * Create the score for a Hymn. All SATB Voices are added as well as all
	 * the verses for the Hymn which are specified to be displayed.
	 * NOTE: When adding parts, the music is named "partVoice," where part is
	 * the name of the part in uppercase (e.g. ALTO).  This is because of the
	 * way LilyPondUtility.makeVoice names the voice variables.
	 * @param song The Hymn to transform into a LilyPond-formatted String.
	 * @return The Hymn score formatted as a LilyPond String.
	 * @author Jason Petersen
	 */
	private String createScore(boolean addLyrics, boolean addChorus) {
		String bar = (addChorus) ? "\\verseBar" : "\\endBar";
		
		String soprano = "\\SOPRANOVoice " + bar;		
		String alto = "\\ALTOVoice " + bar;
		String tenor = "\\TENORVoice " + bar;
		String bass = "\\BASSVoice " + bar;
		
		if(addChorus) {
			soprano += " \\SOPRANOChorus \\endBar";
			alto += " \\ALTOChorus \\endBar";
			tenor += " \\TENORChorus \\endBar";
			bass += " \\BASSChorus \\endBar";
		}
		
		// Create the score
		String toReturn = "\\score {\n";
			// Add ChoirStaff
			toReturn += "\t\\new ChoirStaff <<\n";
				// Add treble clef
				toReturn += "\t\t\\new Staff <<\n";		
					toReturn += "\t\t\t\\clef \"treble\"\n";
					toReturn += "\t\t\t\\new Voice = \"SOPRANO\" { \\voiceOne \\keyTime " + soprano + " }\n";	// Add soprano part
					toReturn += "\t\t\t\\new Voice = \"ALTO\" { \\voiceTwo " + alto + " }\n";	// Add alto part
					// Add lyrics
					if(addLyrics) {
						boolean first = true;
						for(String verseVar : verseVariables){
							toReturn += "\t\t\t\\new Lyrics { \\" + verseVar;
							if(addChorus && first) toReturn += " \\Chorus";
							toReturn += " }\n";
							first = false;
						}
					}
				toReturn += "\t\t>>\n";
				// Add bass clef
				toReturn += "\t\t\\new Staff <<\n";	
					toReturn += "\t\t\t\\clef \"bass\"\n";
					toReturn += "\t\t\t\\new Voice = \"TENOR\" { \\voiceOne \\keyTime " + tenor + " }\n";	// Add tenor part
					toReturn += "\t\t\t\\new Voice = \"BASS\" { \\voiceTwo " + bass + " }\n";	// Add bass part
				toReturn += "\t\t>>\n";
			toReturn += "\t>>\n";
		toReturn += "}\n";
		
		return toReturn;
	}
	
	/**
	 * Create the "score" for just a text.
	 * This is done by adding lyrics for all the verseVariables
	 * as set by createVerses(text) and the verseSkips variable
	 * again set by createVerses(text).
	 * @return The dummy score for the Text.
	 * @author Jason Petersen
	 */
	private String createScoreForText() {
		// Create the score
		String toReturn = "\\score {\n";
			// Add ChoirStaff
			toReturn += "\t\\new ChoirStaff <<\n";
				// Add treble clef
				toReturn += "\t\t\\new Staff <<\n";		
					toReturn += "\t\t\t\\clef \"treble\"\n";
					toReturn += "\t\t\t\\new Voice = \"TREBLE\" { \\verseSkips \\endBar }\n";
					// Add lyrics
					for(String verseVar : verseVariables)
						toReturn += "\t\t\t\\new Lyrics { \\" + verseVar + " }\n";
				toReturn += "\t\t>>\n";
				// Add bass clef
				toReturn += "\t\t\\new Staff <<\n";	
					toReturn += "\t\t\t\\clef \"bass\"\n";
					toReturn += "\t\t\t\\new Voice = \"BASS\" { \\verseSkips \\endBar }\n";
				toReturn += "\t\t>>\n";
			toReturn += "\t>>\n";
		toReturn += "}\n";
		
		return toReturn;
	}
	
	/** 
	 * Create header block for the LilyPond file.
	 * @param hymn The Hymn used to create the header.
	 * @return The LilyPond-formatted String representing the header.
	 * @author Jason Petersen
	 */
	private String createHeader(Hymn hymn) {
		Text text = hymn.getText();
		Tune tune = hymn.getTune();
		
		String toReturn = "\\header {\n";
			toReturn += "\ttitle = \"" + text.getName() + "\"\n";
			toReturn += "\tsubtitle = \"" + tune.getName() + "\"\n";
			toReturn += "\tmeter = \"" + tune.getMeter().toString() + "\"\n";
			toReturn += "\tcomposer = " + createAuthor(tune.getAuthor(), tune.getYear()) + "\n";
			toReturn += "\tpoet = " + createAuthor(text.getAuthor(), text.getYear()) + "\n";
			toReturn += "\ttagline = \"" + tagline + "\"\n";
		toReturn += "}\n";
		return toReturn;
	}
	
	/** 
	 * Create header block for the LilyPond file.
	 * @param tune The Tune used to create the header.
	 * @return The LilyPond-formatted String representing the header.
	 * @author Jason Petersen
	 */
	private String createHeader(Tune tune) {
		String toReturn = "\\header {\n";
			toReturn += "\ttitle = \"" + tune.getName() + "\"\n";
			toReturn += "\tmeter = \"" + tune.getMeter().toString() + "\"\n";
			toReturn += "\tcomposer = " + createAuthor(tune.getAuthor(), tune.getYear()) + "\n";
			toReturn += "\ttagline = \"" + tagline + "\"\n";
		toReturn += "}\n";
		return toReturn;
	}

	/** 
	 * Create header block for the LilyPond file.
	 * @param text The Text used to create the header.
	 * @return The LilyPond-formatted String representing the header.
	 * @author Jason Petersen
	 */
	private String createHeader(Text text) {
		String toReturn = "\\header {\n";
			toReturn += "\ttitle = \"" + text.getName() + "\"\n";
			toReturn += "\tmeter = \"" + text.getMeter().toString() + "\"\n";
			toReturn += "\tpoet = " + createAuthor(text.getAuthor(), text.getYear()) + "\n";
			toReturn += "\ttagline = \"" + tagline + "\"\n";
		toReturn += "}\n";
		return toReturn;
	}
	
	/** 
	 * Function to make the poet/year, composer/year.
	 * This is a little piece of LilyPond flair.
	 * @param name The name of the poet or composer.
	 * @param date The year the poet/composer wrote the piece.
	 * @return A LilyPond-formatted String containing
	 * instructions to italicize the given information.
	 * @author Jason Petersen
	 */
	private String createAuthor(String name, int date) {
		String toReturn = "\\markup \\italic { \"";
		toReturn += name;
		if(date != 0) toReturn += ", " + date;
		toReturn += "\" }";
		return toReturn;
	}
	
	/** 
	 * Create LilyPond variable keyTime which sets the key, time and starting beat
	 * @param tune The Tune used to get the key, time signature and starting beat.
	 * @return The String representing the LilyPond variables keyTime and startBeat.
	 * @author Jason Petersen
	 */
	private String createKeyTime(Tune tune) {
		TimeSignature time = tune.getTimeSignature();
		double start = tune.getStartingBeat();
		
		String toReturn = "keyTime = { " + makeKeySignature(tune.getKeySignature()) + " ";
		toReturn += makeTimeSignature(time);
		
		int smallestInFirst = smallestNotesInFirstMeasure(time, start);
		if(smallestInFirst != 0) toReturn += " \\partial " + increaseFromSmallestNote(smallestInFirst);
		
		toReturn += " }\n";
		return toReturn;
	}
	
	/**
	 * Build the block of Voices for the Tune.
	 * They will be named with the voice name plus Voice, 
	 * e.g. "SOPRANOVoice"
	 * Alleluias are integrated automatically. The alleluia lyrics,
	 * however, need to be created with a separate call to createAlleluiaLyrics.
	 * @param tune The tune for which to build the block of Voices.
	 * @return The block of Voices for the given Tune.
	 * @author Jason Petersen
	 */
	private String createVoices(Tune tune) {
		Music music = tune.getMusic();
		if(music == null) return "";
		
		String toReturn = "";
		
		for(Iterator<Voice> voices = music.iterator(); voices.hasNext(); ) {
			Voice v = voices.next();
			toReturn += v.getPart().toString().toUpperCase() + "Voice\t= {"; 
			
			int line = 1;
			for(Iterator<Line<Unit>> lines = v.iterator(); lines.hasNext(); ) {
				for(Iterator<Unit> units = lines.next().iterator(); units.hasNext(); )
					for(Iterator<Note> notes = units.next().iterator(); notes.hasNext(); )
						toReturn += makeNote(notes.next()) + " ";
				
				// Add the alleluia notes for the current line, if it exists
				Refrain alleluia = tune.getAlleluiaForLine(line);
				if(alleluia != null){
					Voice alleluiaVoice = alleluia.getMusic().getVoiceFor(v.getPart());
					for(Iterator<Line<Unit>> alleluiaLines = alleluiaVoice.iterator(); alleluiaLines.hasNext(); ) {
						for(Iterator<Unit> alleluiaUnits = alleluiaLines.next().iterator(); alleluiaUnits.hasNext(); ) {
							for(Iterator<Note> notes = alleluiaUnits.next().iterator(); notes.hasNext(); ) {
								toReturn += makeNote(notes.next()) + " ";
							}
						}
					}
				}
				
				line++;
			}
			
			toReturn += "}\n";
		}
		
		return toReturn;
	}
	
	/**
	 * Create the block of verses as LilyPond variables,
	 * using the Tune for the Hymn to determine syllable lengths.
	 * @param hymn Hymn for which to create the verses block.
	 * @return The block of verses for the given Hymn as LilyPond variables.
	 * @author Jason Petersen
	 */
	private String createVerses(Hymn hymn) {
		int totalToDisplay = hymn.numberOfVersesToDisplay();
		if(totalToDisplay < 1) return "";

		Tune tune = hymn.getTune();
		Text text = hymn.getText();
		String toReturn = "";
		
		int verseNumber = 1;
		boolean skip = false;
		
		if(hymn.doubleText()){
			for(Iterator<Lyric> verses = text.iterator(); verses.hasNext(); ){
				if(hymn.display(verseNumber)){ // Only add verses we want to display
					String name = "Verse" + numberStrings[verseNumber];
					toReturn += name + "\t= { \\set stanza = #\"" + (verseNumber) + ". \" \\lyricmode { ";
					verseVariables.add(name);
					
					toReturn += makeHymnLyric(verses.next(), tune, skip, 0);
					toReturn += makeHymnLyric(verses.next(), tune, skip, text.getMeter().numberOfLines());
					
					toReturn += " } }\n";
					
					skip = true;
				}
				else {
					if(verses.hasNext()) verses.next(); // Advance the iterator twice
					else break;
					if(verses.hasNext()) verses.next();
					else break;
				}
				verseNumber++;
			}
		}
		else {
			for(Iterator<Lyric> verses = text.iterator(); verses.hasNext(); ){
				if(hymn.display(verseNumber)){ // Only add verses we want to display
					String name = "Verse" + numberStrings[verseNumber];
					toReturn += name + "\t= { \\set stanza = #\"" + verseNumber + ". \" \\lyricmode { ";
					toReturn += makeHymnLyric(verses.next(), tune, skip, 0) + " } }\n";
					verseVariables.add(name);
					skip = true;
				}
				else verses.next(); // Advance the iterator
				verseNumber++;
			}
		}
		
		return toReturn;
	}
	
	/**
	 * Create the verses and verseSkip variable
	 * for a text, not using any tune.
	 * @param text The text for which to create the verses.
	 * @return The verses as a lilypond block.
	 * @author Jason Petersen
	 */
	private String createVerses(Text text) {
		String toReturn = "";
		
		toReturn += "verseSkips = \\repeat unfold " + text.getMeter().numberOfSyllables() + " { \\skip 4 }\n\n";
		
		int verseNumber = 1;
		for(Iterator<Lyric> verses = text.iterator(); verses.hasNext(); ) {
			String name = "Verse" + numberStrings[verseNumber];
			toReturn += name + "\t= { \\set stanza = #\"" + (verseNumber) + ". \" \\lyricmode { ";
			verseVariables.add(name);
			
			for(Iterator<Line<Word>> lines = verses.next().iterator(); lines.hasNext(); ) {
				for(Iterator<Word> words = lines.next().iterator(); words.hasNext(); ) {
					toReturn += buildLyricSyllable(words.next(), 4);
				}
			}
			
			toReturn += " } }\n";
			verseNumber++;
		}
		return toReturn;
	}
	
	/**
	 * Create the LilyPond variables for the alleluia lyrics.
	 * For each alleluia, a skip variable is also created, e.g.
	 * \AlleluiaOne and \skipAlleluiaOne
	 * @param tune The Tune which is used to get the alleluias.
	 * @return A block of all the alleluia lyrics/skips
	 * @author Jason Petersen
	 */
	private String createAlleluiaLyrics(Tune tune) {
		String toReturn = "";
		Meter meter = tune.getMeter();
		
		for(int i=0; i<meter.numberOfLines(); i++){
			Refrain alleluia = tune.getAlleluiaForLine(i + 1);
			
			if(alleluia != null){
				Lyric lyric = alleluia.getLyric();
				String name = "Alleluia" + numberStrings[i+1];
				
				Voice melody = alleluia.getMusic().getVoiceFor(tune.getMelody());
				
				// Create alleluia lyric
				toReturn += createRefrainLyric(lyric, melody, name);
				
				// Create alleluia lyric skip
				int skip = 0;
				for(Iterator<Line<Word>> lines = lyric.iterator(); lines.hasNext(); ) {
					for(Iterator<Word> words = lines.next().iterator(); words.hasNext(); ) {
						words.next();
						skip++;
					}
				}
				// I'm not sure why we need to subtract here, but it seems to work
				toReturn += "skip" + name + "\t= \\repeat unfold " + (skip-1) + " { \\lyricmode { _ } }\n"; // See http://old.nabble.com/skip-lyrics-td31109981.html
			}
		}
		
		return toReturn;
	}
	
	/**
	 * Create the LilyPond variables associated with the chorus,
	 * i.e. the voices ("SOPRANOChorus") and the lyrics ("Chorus")
	 * if the tune has a chorus.
	 * @param tune The Tune for which to get the chorus Refrain and melody
	 * to build the chorus LilyPond variables.
	 * @return The block of LilyPond chorus variables.
	 * @author Jason Petersen
	 */
	private String createChorus(Tune tune) {
		String toReturn = "";
		Refrain chorus = tune.getChorus();
		
		if(chorus != null){
			// Add chorus voices
			Music music = chorus.getMusic();
			for(Iterator<Voice> voices = music.iterator(); voices.hasNext(); ){
				Voice v = voices.next();
				toReturn += v.getPart().toString().toUpperCase() + "Chorus\t= {";
				
				// Refrains should only have one line, we're assuming valid input here
				for(Iterator<Line<Unit>> lines = v.iterator(); lines.hasNext(); )
					for(Iterator<Unit> units = lines.next().iterator(); units.hasNext(); )
						for(Iterator<Note> notes = units.next().iterator(); notes.hasNext(); )
							toReturn += makeNote(notes.next()) + " ";
				
				toReturn += "}\n";
			}
			toReturn += "\n";
			
			// Get the chorus voice corresponding to the tune's melody
			Voice melody = chorus.getMusic().getVoiceFor(tune.getMelody());
			
			// Add chorus lyrics
			toReturn += createRefrainLyric(chorus.getLyric(), melody, "Chorus");
		}
		
		return toReturn;
	}
	
	/**
	 * Create a LilyPond variable with the given name representing the Lyric.
	 * The difference between this and makeHymnLyric are as follows:
	 * 1. The lyrics are centered relative to the other lyrics
	 * 2. There is no checking for lengths.
	 * 3. This actually makes a variable.
	 * @param lyric The lyric for the Refrain.
	 * @param melody The melody Voice used to determine the length of
	 * each of the Words.
	 * @param name The name of the variable to make, e.g. "Chorus" or "AlleluiaOne"
	 * @return A LilyPond variable representing the lyric, called the given name.
	 * @author Jason Petersen
	 */
	private String createRefrainLyric(Lyric lyric, Voice melody, String name) {
		String toReturn = "";
		
		toReturn += name + "\t= \\lyricmode { \\dropLyrics ";
		
		Iterator<Line<Unit>> melodyLines = melody.iterator();
		Iterator<Line<Word>> lyricLines = lyric.iterator();
		
		// Refrains should only have one line, and we should be getting a valid Refrain from
		// the Tune, so we're assuming valid input here
		while(melodyLines.hasNext() && lyricLines.hasNext()) {
			Iterator<Unit> units = melodyLines.next().iterator();
			Iterator<Word> words = lyricLines.next().iterator();
			while(units.hasNext() && words.hasNext())
				toReturn += buildLyricSyllable(words.next(), units.next().duration()); 
		}
			
		toReturn += "\\raiseLyrics }\n";
		
		return toReturn;
	}

	/* ---------- Helper methods to make a LilyPond formatted String from model objects ---------- */
	
	/**
	 * By far the most complicated block. Basically in addition to adding
	 * the normal lyrics, after each line we need to check if we need to
	 * add a placeholder for an alleluia (i.e. "\AlleluiaOne" or "\skipAlleluiaOne").
	 * The skipping is determined by the skip parameter.  Additionally,
	 * is the Unit associated with the Word in the Lyric needs to be repeated,
	 * we need to add those Words twice. The algorithm below has additonal comments
	 * which should make it relatively easy to follow.
	 * @param lyric The Lyric to format properly.
	 * @param tune The Tune used to get the Units for the melody.
	 * @param skip Whether or not to skip the alleluia lyrics.
	 * @param linesProcessed The number of lines processed so far, used for lyric doubling.
	 * @return A LilyPond formatted String NOT enclosed by brackets representing the
	 * given Lyric. This does not create a variable, the result will need to be wrapped as such.
	 * @author Jason Petersen
	 */
	private String makeHymnLyric(Lyric lyric, Tune tune, boolean skip, int linesProcessed) {
		Part melody = tune.getMelody();
		
		Iterator<Line<Word>> lyricLines = lyric.iterator();
		Iterator<Line<Unit>> melodyLines = tune.getMusic().getVoiceFor(melody).iterator();
		
		while(linesProcessed > 0) {
			melodyLines.next();
			linesProcessed--;
		}
		
		ArrayList<Word> lyricWords = new ArrayList<Word>();
		while(lyricLines.hasNext()){
			for(Iterator<Word> words = lyricLines.next().iterator(); words.hasNext(); ) {
				lyricWords.add(words.next());
			}
		}
		
		boolean previousRepeat = false;
		ArrayList<Word> repeatedWords = new ArrayList<Word>();
		Iterator<Unit> units = null;
		Unit u = null;
		
		String toReturn = "";
		int line = 1;
		int index = 0;
		
		while(melodyLines.hasNext()) {
			units = melodyLines.next().iterator(); // Used to get the lyric durations
			
			while(units.hasNext()) {
				u = units.next();
				Word w = null;
				if(index < lyricWords.size())
					w = lyricWords.get(index);
				else {
					for(int i=0; i<repeatedWords.size(); i++){
						toReturn += buildLyricSyllable(repeatedWords.get(i), u.duration());
						if(!units.hasNext()) {
							if(!melodyLines.hasNext())
								break;
							units = melodyLines.next().iterator();
						}
						u = units.next();
					}
					break;
				}
				
				// Determine if the current word gets repeated
				boolean repeat = u.getWordRepeat();
				if(repeat) repeatedWords.add(w);
				
				// If we're no longer repeating, need to add repeats
				if(!repeat && previousRepeat){
					for(int i=0; i<repeatedWords.size(); i++){
						toReturn += buildLyricSyllable(repeatedWords.get(i), u.duration());
						if(!units.hasNext())
							units = melodyLines.next().iterator();
						u = units.next();
					}
					repeatedWords.clear();
				}
				
				// Add the current word using the corresponding unit for duration
				toReturn += buildLyricSyllable(w, u.duration());
				
				previousRepeat = repeat;
				index++;
			}
		
			// Add alleluia placeholder, if any
			Refrain alleluia = tune.getAlleluiaForLine(line);
			if(alleluia != null){
				toReturn += "\\";
				if(skip) toReturn += "skip";
				toReturn += "Alleluia" + numberStrings[line] + " ";
			}
			
			line++;
		}
		
		return toReturn.trim();
	}
	
	/** 
	 * Write out KeySignature to LilyPond-formatted String.
	 * @param key KeySignature to write out to LilyPond-formatted String.
	 * @return The KeySignature as a LilyPond-formatted String.
	 * @author Jason Petersen
	 */
	private String makeKeySignature(KeySignature key) {
		String name = key.majorName();
		StringTokenizer token = new StringTokenizer(name.toLowerCase());
	
		// Add key
		String toReturn = "\\key " + token.nextToken();
		
		// Add flat or sharp to key		
		String next = token.nextToken();
		if(next.equals("flat")){
			toReturn += flat;
			next = token.nextToken();
		}
		else if(next.equals("sharp")){
			toReturn += sharp;
			next = token.nextToken();
		}
		
		// Add major or minor;
		toReturn += " \\" + next; 
			
		return toReturn;
	}

	/**
	 * Write out TimeSignature to LilyPond-formatted String.
	 * @param time TimeSignature to write out to LilyPond-formatted String.
	 * @return The TimeSignature as an LilyPond-formatted String.
	 * @author Jason Petersen
	 */
	private String makeTimeSignature(TimeSignature time) {
		String toReturn = "\\time ";
		toReturn += time.getNumBeats() + "/" + time.getBeatLength();
		return toReturn;
	}
	
	/**
	 * Write out Note to LilyPond-formatted String.
	 * @param note Note to write out to LilyPond-formatted String.
	 * @return The Note as an LilyPond-formatted String.
	 * @author Jason Petersen
	 */
	private String makeNote(Note note) {
		Slur slur = note.slurStatus();
		Accidental accidental = note.getAccidental();
		String pitch = note.getPitchName().toLowerCase();
		
		String toReturn = "";
		if(note.isRest()) return "r" + note.getDurationDenom();
		
		// Add pitch
		toReturn += pitch.charAt(0) + "";
		
		// Add accidentals - see notes from data.TuneInputSpecification as to why we don't need
		// to consider accidentals from the key when using LilyPond.
		if(accidental.equals(Accidental.FLAT)) toReturn += flat;
		if(accidental.equals(Accidental.SHARP)) toReturn += sharp;
		
		// Change pitch's location on staff - instead of using \relative, use absolute pitch		
		int oct = Integer.parseInt(pitch.charAt(pitch.length()-1) + "") - 3;
		if(oct < 0)															
			while(oct < 0){ toReturn += ","; oct++;}						
		if(oct > 0)
			while(oct > 0){ toReturn += "'"; oct--;} 
		
		// Add duration
		toReturn += note.getDurationDenom();
		
		// Add dot
		if(note.isDotted()) toReturn += ".";
		
		// Add tie
		if(note.startsTie()) toReturn += "~";
		
		// Add slur
		if(slur.equals(Slur.BEGIN)) toReturn += "(";
		if(slur.equals(Slur.END)) toReturn += ")";

		return toReturn;
	}
	
	/* ---------- Helper functions ---------- */
	
	/**
	 * Build a lyric syllable using the duration of the given Unit.
	 * See http://lilypond.org/doc/v2.12/Documentation/user/lilypond/Entering-lyrics
	 * @param w The lyric syllable to build into a String.
	 * @param d The duration to use for this Word.
	 * @return The lyric, all pretty and with proper duration,
	 * with a space at the end.
	 * @author Jason Petersen
	 */
	private String buildLyricSyllable(Word w, int d) {
		String toReturn = "";
		
		int num = w.numberOfStrings();
		String duration = increaseFromSmallestNote(d);
		
		if(num == 1){
			toReturn = replaceLyricQuote(w.toString());
			if(!toReturn.equals(Word.skip)){
				boolean addDash = false;
				if(toReturn.contains("-")){
					toReturn = toReturn.replace("-", ""); // Dash at the end of the word needs to get chopped off
					addDash = true;
				}
				toReturn += duration + ((addDash) ? " -- " : " ");
			}
			else toReturn = "_ "; // Lyric skip
		}
		else if(num != 0) {
			for(Iterator<String> strings = w.iterator(); strings.hasNext(); ){
				String next = strings.next();
				if(!next.equals(Word.skip)){ // Skip the skips
					next = replaceLyricQuote(next);
					toReturn += next + " ";
				}
			}
			
			// Add quotes around String, replace dashes with space and dash
			toReturn = "\"" + toReturn.trim().replaceAll("-", " -") + "\"" + duration + " ";
		}
		
		return toReturn;
	}
	
	/**
	 * Function which takes an integer representing a duration
	 * in terms of Note.SMALLESTNOTE and returns a LilyPond-formatted
	 * String representing the duration in terms of the largest possible
	 * duration. For example, if Note.SMALLESTNOTE is 16, y is 6, this will
	 * return "8*3", or if y was 4, this will return "4"
	 * @param y The integer representing a duration in terms of Note.SMALLESTNOTE
	 * @return The LilyPond-formatted String duration in terms of the largest
	 * possible duration.
	 * @author Jason Petersen
	 */
	private String increaseFromSmallestNote(int y) {
		if(y == 0) return "0";

		int x = Note.SMALLESTNOTE;
		while(y%2 == 0){
			y = y/2;
			x = x/2;
		}
		return (y == 1) ? x + "" : x + "*" + y;
	}
	
	/**
	 * Helper function to calculate the number of notes in the first measure
	 * in terms of model.Note.SMALLESTNOTE.
	 * @param time The TimeSignature for the Tune we are processing.
	 * @param start The starting beat for the Tune we are processing.
	 * @return The number of smallest notes in the first measure in terms
	 * of model.Note.SMALLESTNOTE
	 * @author Jason Petersen
	 */
	private int smallestNotesInFirstMeasure(TimeSignature time, double start) {
		int smallestNotesPerBeat = (Note.SMALLESTNOTE/time.getBeatLength());
		return (int) (time.getNumBeats() - (start-1))*smallestNotesPerBeat; 
	}
	
	/**
	 * LilyPond is stupid and needs the quotes
	 * escaped in a really odd way. This does that.
	 * @param s The String in which to replace the quotes.
	 * @return The String with quotes all nice for LilyPond
	 * @author Jason Petersen
	 */
	private String replaceLyricQuote(String s) {
		if(s == null) return "";
		
		if(s.contains("\"")){
			s = s.replaceAll("\"", "\\\\\"");
			return "\"" + s + "\"";
		}
		return s;
	}

}
